<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System" #>
<#@ assembly name="System.ComponentModel.DataAnnotations" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.IO" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="System.Text.Encoding" #>
<#@ assembly name="System.Threading.Tasks" #>
<#@ assembly name="$(SolutionDir)packages\Microsoft.CodeAnalysis.Common.1.0.0\lib\net45\Microsoft.CodeAnalysis.dll" #>
<#@ assembly name="$(SolutionDir)packages\Microsoft.CodeAnalysis.CSharp.1.0.0\lib\net45\Microsoft.CodeAnalysis.CSharp.dll" #>
<#@ assembly name="$(SolutionDir)packages\System.Collections.Immutable.1.1.36\lib\portable-net45+win8+wp8+wpa81\System.Collections.Immutable.dll" #>
<#@ assembly name="$(TargetPath)" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.ComponentModel" #>
<#@ import namespace="System.ComponentModel.DataAnnotations.Schema" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="Microsoft.CodeAnalysis" #>
<#@ import namespace="Microsoft.CodeAnalysis.CSharp" #>
<#@ import namespace="Microsoft.CodeAnalysis.CSharp.Syntax" #>
<#@ import namespace="Microsoft.CodeAnalysis.Text" #>
<#@ import namespace="BGC.WebAPI" #>
<#@ output extension=".cs" #>
using System.Collections.Generic;

namespace <#= typeof(BGC.WebAPI.LocalizationDictionary).Namespace #>
{
	<#
	using (FileStream file = File.Open(this.Host.ResolvePath("LocalizationDictionary.cs"), FileMode.Open))
	{
		ClassDeclarationSyntax rootDeclaration = GetClassDeclaration(file);
		LocalizationTypeDeclaration localization = GetLocalizationTypeSubTree(rootDeclaration);
		WriteClassDataRecursively(localization, 1);
	}
	#>
}
<#+
	static class SyntaxExtensions
	{
		public static IEnumerable<SyntaxToken> AttributeDeclarations(BaseTypeDeclarationSyntax declaration)
		{
			IEnumerable<SyntaxToken> result = declaration.AttributeLists.SelectMany(list => list.Attributes.Select(attr => (attr.Name as IdentifierNameSyntax).Identifier));
			return result;
		}

		public static IEnumerable<AttributeSyntax> AttributeDeclarations(BaseFieldDeclarationSyntax declaration)
		{
			IEnumerable<AttributeSyntax> result = declaration.AttributeLists.SelectMany(list => list.Attributes);
			return result;
		}

		public static bool HasAttribute<TAttribute>(BaseTypeDeclarationSyntax declaration)
			where TAttribute : Attribute
		{
			return AttributeDeclarations(declaration).Any(token => token.Text == typeof(TAttribute).Name || (token.Text + typeof(Attribute).Name) == typeof(TAttribute).Name);
		}

		public static AttributeSyntax GetAttributeDeclaration<TAttribute>(BaseFieldDeclarationSyntax fieldDeclaration)
			where TAttribute : Attribute
		{
			return AttributeDeclarations(fieldDeclaration).FirstOrDefault(syntax => syntax.Name.GetText().ToString() == typeof(TAttribute).Name || (syntax.Name.GetText().ToString() + typeof(Attribute).Name) == typeof(TAttribute).Name);
		}

		public static IEnumerable<ClassDeclarationSyntax> Containers(ClassDeclarationSyntax declaration)
		{
			List<ClassDeclarationSyntax> result = new List<ClassDeclarationSyntax>();
			SyntaxNode parent = declaration.Parent;
			while (parent != null)
			{
				if (parent is ClassDeclarationSyntax) result.Add(parent as ClassDeclarationSyntax);
				else break;
				parent = parent.Parent;
			}
			return result;
		}
	}

	public class LocalizationTypeDeclaration
	{
		public string GetFullName()
		{
			return string.Format("{0}{1}{2}{3}{4}",
				this.Namespaces.Aggregate(new StringBuilder(""), (sb, curr) => sb.AppendFormat("{0}.", curr), sb => (sb.Length > 0 ? sb.Remove(sb.Length - 1, 1) : sb).ToString()),
				this.Namespaces.Any() ? "." : "",
				this.ContainerClasses.Aggregate(new StringBuilder(""), (sb, curr) => sb.AppendFormat("{0}.", curr), sb => (sb.Length > 0 ? sb.Remove(sb.Length - 1, 1) : sb).ToString()),
				this.ContainerClasses.Any() ? "." : "",
				this.TypeName);
		}

		public IEnumerable<string> Namespaces { get; private set; }

		public IEnumerable<string> ContainerClasses { get; private set; }

		public string TypeName { get; private set; }

		public IEnumerable<string> LocalizationKeyFields { get; private set; }

		public IEnumerable<LocalizationTypeDeclaration> SubTypes { get; private set; }

		public LocalizationTypeDeclaration(ClassDeclarationSyntax localizationKeyClass, IEnumerable<FieldDeclarationSyntax> localizationKeyFields, IEnumerable<LocalizationTypeDeclaration> subTypes = null)
		{
			this.TypeName = localizationKeyClass.Identifier.Text;

			List<string> containerClasses = new List<string>();
			List<string> namespaces = new List<string>();
			SyntaxNode declaringNode = localizationKeyClass.Parent;
			while (declaringNode != null)
			{
				if (declaringNode is ClassDeclarationSyntax) containerClasses.Add((declaringNode as ClassDeclarationSyntax).Identifier.Text);
				else if (declaringNode is NamespaceDeclarationSyntax) namespaces.Add((declaringNode as NamespaceDeclarationSyntax).Name.GetText().ToString());
				declaringNode = declaringNode.Parent;
			}
			containerClasses.Reverse();
			namespaces.Reverse();
			this.ContainerClasses = containerClasses;
			this.Namespaces = namespaces;

			this.LocalizationKeyFields = localizationKeyFields.Select(field => field.Declaration.Variables.OfType<VariableDeclaratorSyntax>().First().Identifier.Text).ToList();
			this.SubTypes = subTypes ?? Enumerable.Empty<LocalizationTypeDeclaration>();
		}

		public override string ToString()
		{
			return this.GetFullName();
		}
	}

	static readonly string Indent = "    ";

	static readonly string LocalizationSuffix = BGC.WebAPI.LocalizationDictionary.LocalizationSuffix;

	static readonly string LocalizationDictionaryParameterName = "localizedStrings";

	static readonly string LocalizationDictionaryPropertyName = "LocalizedStrings";

	static string ToSentenceCase(string s)
	{
		string result = char.ToUpper(s[0]) + s.Substring(1);
		return result;
	}

	static LocalizationTypeDeclaration GetLocalizationTypeSubTree(ClassDeclarationSyntax localizationTypeDeclaration)
	{
		return new LocalizationTypeDeclaration(
			localizationTypeDeclaration,
			localizationTypeDeclaration.ChildNodes()
				.OfType<FieldDeclarationSyntax>()
				.Where(field =>
				{
					AttributeSyntax localizableAttribute = SyntaxExtensions.GetAttributeDeclaration<LocalizableAttribute>(field);
					return
						field.Modifiers.Any(token => token.Text == "static") &&
						(localizableAttribute == null ||
							localizableAttribute.ArgumentList.Arguments.Any(arg => arg.Expression is LiteralExpressionSyntax && !false.Equals((arg.Expression as LiteralExpressionSyntax).Token.Value)));
				}),
			localizationTypeDeclaration.ChildNodes()
				.OfType<ClassDeclarationSyntax>()
				.Select(declaration => GetLocalizationTypeSubTree(declaration)).ToList());
	}

	static ClassDeclarationSyntax GetClassDeclaration(FileStream file)
	{
		var tree = CSharpSyntaxTree.ParseText(SourceText.From(file));
		var root = tree.GetRoot();
		ClassDeclarationSyntax rootDeclaration = null;
		Queue<SyntaxNode> search = new Queue<SyntaxNode>();
		search.Enqueue(root);
		while (search.Any())
		{
			SyntaxNode current = search.Dequeue();
			foreach (SyntaxNode child in current.ChildNodes())
			{
				ClassDeclarationSyntax _class = child as ClassDeclarationSyntax;
				if (_class != null && SyntaxExtensions.Containers(_class).All(decl => decl.Modifiers.Any(token => token.Text == "partial")))
				{
					rootDeclaration = _class;
					break;
				}
				else
				{
					search.Enqueue(child);
				}
			}
		}
		return rootDeclaration;
	}

	static string NestedLocalizationTypePropertyName(LocalizationTypeDeclaration t)
	{
		return t.TypeName.Substring(0, t.TypeName.Length - LocalizationSuffix.Length);
	}

	void WriteClassDataRecursively(LocalizationTypeDeclaration declaringType, int initialIndentation)
	{
		for (int i = 0; i < initialIndentation; i++)
		{
			this.PushIndent(Indent);
		}

		this.Write("public partial class {0}\r\n{{\r\n", declaringType.TypeName);
		this.PushIndent(Indent);

		IEnumerable<LocalizationTypeDeclaration> nestedLocalizationTypes = declaringType.SubTypes;
		foreach (LocalizationTypeDeclaration nestedType in nestedLocalizationTypes)
		{
			WriteClassDataRecursively(nestedType, 0);
		}

		IEnumerable<string> keyNameFields = declaringType.LocalizationKeyFields;
		foreach (string field in keyNameFields)
		{
			this.Write("public {0} {1} {{ get; private set; }}\r\n", typeof(LocalizedString).Name, ToSentenceCase(field));
		}
		
		if (keyNameFields.Any() && nestedLocalizationTypes.Any()) this.Write("\r\n");
		foreach (LocalizationTypeDeclaration nestedType in nestedLocalizationTypes)
		{
			this.Write("public {0} {1} {{ get; private set; }}\r\n", nestedType.TypeName, NestedLocalizationTypePropertyName(nestedType));
		}

		if (nestedLocalizationTypes.Any()) this.Write("\r\n");
		this.Write("public {0}(IDictionary<string, string> {1})\r\n", declaringType.TypeName, LocalizationDictionaryParameterName);
		this.Write("{\r\n");
		this.PushIndent(Indent);
		this.Write("this.{0} = {1};\r\n", LocalizationDictionaryPropertyName, LocalizationDictionaryParameterName);
		
		if (nestedLocalizationTypes.Any()) this.Write("\r\n");
		foreach (LocalizationTypeDeclaration type in nestedLocalizationTypes)
		{
			string nestedTypePropertyName = NestedLocalizationTypePropertyName(type);
			this.Write("this.{0} = new {1}(this.{2});\r\n", nestedTypePropertyName, type.TypeName, LocalizationDictionaryPropertyName);
		}

		if (nestedLocalizationTypes.Any() && keyNameFields.Any()) this.Write("\r\n");
		foreach (string field in keyNameFields)
		{
			this.Write("this.{0} = new {1}({2}.{3}, this.{4});\r\n", ToSentenceCase(field), typeof(LocalizedString).Name, declaringType.TypeName, field, LocalizationDictionaryPropertyName);
		}

		this.PopIndent();
		this.Write("}\r\n\r\n");

		this.Write("private IDictionary<string, string> {0} {{ get; set; }}\r\n", LocalizationDictionaryPropertyName);
		this.PopIndent();
		this.Write("}\r\n");

		for (int i = 0; i < initialIndentation; i++)
		{
			this.PopIndent();
		}
	}
#>